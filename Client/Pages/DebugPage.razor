@page "/debug"
@using Models
@using System.Threading
@using System.Numerics
@using pwa.Shared
@using pwa.Client.Services
@using Microsoft.Extensions.Logging
@inject HttpClient Http
@inject IJSRuntime _js
@inject ILogger<DebugPage> _logger
@inject DataService dataService
@implements IDisposable

@if (Run != null)
{
    <p>
        <span>Items: @Run.RunItems.Count</span>
    </p>
    <div class="btn-block">
    <button type="button" class="btn btn-primary" @onclick="ShowLine">ShowLine</button>
    <button type="button" class="btn btn-primary" @onclick="GetLocation">GetLocation</button>
    <button type="button" class="btn btn-primary" @onclick="Start">Start</button>
    <button type="button" class="btn btn-primary" @onclick="Stop">Stop</button>
    </div>
}

<div id="mapid" style="width: 90%; max-width: 900px; height: 500px;">
</div>

<div>
    <p>
        Request: @geo.Request.ToLocalTime()
    </p>
    <p>
        Duration: @geo.Duration.TotalSeconds s
    </p>
    <p>
        Error: @geo.Error
    </p>

    @if (geo.RunItem != null) {
        <p>
        Lat/Long: @geo.RunItem.Latitude | @geo.RunItem.Latitude | @geo.RunItem.Accuracy
        </p>
    }
</div>
@if (Run != null) {

    <div class="mt-5 mb-5">
        <h4 class="text-white-50">Startzeit: @Run.RunInfo.StartTime.ToLocalTime()</h4>
        <h4 class="text-white-50">Du hast @Run.RunInfo.Distance m in @Run.RunInfo.Duration.ToString(@"hh\:mm\:ss")
            zurückgelegt!</h4>
        <h4><span class="badge badge-info">&empty;-Geschwindigkeit: @Run.RunInfo.Kph km/h</span></h4>
        <h4><span class="badge badge-info">Höchstgeschwindigkeit: @Run.RunInfo.KphMax km/h</span></h4>
        <h4><span class="badge badge-info">Gemessene Punkte: @Run.RunItems.Count</span></h4>
    </div>
}
@code {
    Run Run;
    private static Action<double[]> action;
    private static Action<string> actionErr;
    private GetLocationModel geo = new GetLocationModel();
    private Task runTask;
    private CancellationTokenSource source;
    private List<string> errors = new List<string>();
    DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
    protected override async Task OnInitializedAsync()
    {
        action = GeoData;
        actionErr = Error;
        var debugModel = await Http.GetFromJsonAsync<RunDebugModel>("api/gettestdata");
        Run = new Run()
        {
            RunItems = debugModel.RunDebugItems.Select(s => new RunItem()
            {
                Latitude = s.Latitude,
                Longitude = s.Longitude,
                TimeStamp = (new DateTime((long)s.TimeStamp).ToUniversalTime() - epoch).TotalMilliseconds,
                Accuracy = s.Accuracy,
                Speed = s.Speed
            }).ToList()
        };
        Run.RunInfo.StartTime = debugModel.Start;
        Run.RunInfo.StopTime = debugModel.Stop;
        try
        {
            var mapUp = await _js.InvokeAsync<bool>("LoadMap");
        }
        catch { }
    }

    private async void ShowLine()
    {
        Run.RunItems = Run.FilterData();
        HashSet<string> uniques = new HashSet<string>();
        List<double[]> items = new List<double[]>();
        DateTime start = Run.RunInfo.StartTime;
        double averageAccuracy = Run.RunItems.Select(s => s.Accuracy).Average();
        double worstAccuracy = Run.RunItems.Select(s => s.Accuracy).Max();
        double bestAccuracy = Run.RunItems.Select(s => s.Accuracy).Min();
        double critAccuracy = averageAccuracy * 2;
        for (int i = 0; i < Run.RunItems.Count; i++)
        {
            var pos = new double[] { Run.RunItems[i].Latitude, Run.RunItems[i].Longitude };
            var uniquestring = Run.RunItems[i].Latitude.ToString() + "|" + Run.RunItems[i].Longitude.ToString() + " (" + Run.RunItems[i].Accuracy + ")";
            // if (uniques.Contains(uniquestring))
            //    continue;
            if (i > 0) {
                Run.RunItems[i].Angle = angleFromCoordinate(Run.RunItems[i-1].Latitude, Run.RunItems[i-1].Longitude, Run.RunItems[i].Latitude, Run.RunItems[i].Longitude);
                Run.RunItems[i].Distance = GetDistance(Run.RunItems[i-1].Latitude, Run.RunItems[i-1].Longitude, Run.RunItems[i].Latitude, Run.RunItems[i].Longitude);
                Run.RunItems[i].TimeSpan = Run.RunItems[i].GetTime() - Run.RunItems[i - 1].GetTime();
            }
            _logger.LogInformation($"Timespan {i}: {Run.RunItems[i].TimeSpan.TotalSeconds}, Distance: {Run.RunItems[i].Distance}, Speed: {Run.RunItems[i].SpeedInKmH}, Accuracy: {Run.RunItems[i].Accuracy}, Angle: {Run.RunItems[i].Angle}");
            start = Run.RunItems[i].GetTime();
            items.Add(pos);
            // await _js.InvokeVoidAsync("AddMarker", Run.RunItems[i].Latitude, Run.RunItems[i].Longitude, Run.RunItems[i].Accuracy, i);
            uniques.Add(uniquestring);
        }
        _logger.LogInformation($"Unique Items: {items.Count}");
        _logger.LogInformation($"Avg accuracy: {Run.RunItems.Select(s => s.Accuracy).Average()}, Max: {Run.RunItems.Select(s => s.Accuracy).Max()}, Min: {Run.RunItems.Select(s => s.Accuracy).Min()}");
        Run.RunItems.Remove(Run.RunItems.First());
        _logger.LogInformation($"Avg distance: {Run.RunItems.Select(s => s.Distance).Average()}, Max: {Run.RunItems.Select(s => s.Distance).Max()}, Min: {Run.RunItems.Select(s => s.Distance).Min()}");
        _logger.LogInformation($"Avg timespan: {Run.RunItems.Select(s => s.TimeSpan.TotalSeconds).Average()}, Max: {Run.RunItems.Select(s => s.TimeSpan.TotalSeconds).Max()}, Min: {Run.RunItems.Select(s => s.TimeSpan.TotalSeconds).Min()}");
        _logger.LogInformation($"Avg speed: {Run.RunItems.Select(s => s.SpeedInKmH).Average()}, Max: {Run.RunItems.Select(s => s.SpeedInKmH).Max()}, Min: {Run.RunItems.Select(s => s.SpeedInKmH).Min()}");
        // await _js.InvokeVoidAsync("AddLine", Run.RunItems.Select(s => new double[] { s.Latitude, s.Longitude }).ToList(), "red");
        Run.GetFinalRunInfo();
        StateHasChanged();
        // await _js.InvokeVoidAsync("AddLine", items, "red");
        var lines = Run.GetLines();
        foreach (var line in lines) {
            await _js.InvokeVoidAsync("AddLine", line.Line, line.Color);
        }
    }

    private void Start() {
        Run = new Run();
        Run.RunInfo.StartTime = DateTime.UtcNow;
        source = new CancellationTokenSource();
        runTask = Task.Run( async() => {
            while (true) {
                await Task.Delay(1000, source.Token);
                if (source.Token.IsCancellationRequested)
                    break;
                await GetLocation();
            }
        }, source.Token);
    }

    private async void Stop() {
        Run.RunInfo.StopTime = DateTime.UtcNow;
        Run.GetFinalRunInfo();
        if (runTask != null && source != null) {
            source.Cancel();
        }
        await _js.InvokeVoidAsync("AddLine", Run.RunItems.Select(s => new double[] { s.Latitude, s.Longitude }).ToList(), "red");
        await dataService.SendDebugRun(new RunDebugModel() {
                Start = Run.RunInfo.StartTime,
                Stop = Run.RunInfo.StopTime,
                Errors = errors,
                RunDebugItems = Run.RunItems.Select(s => new RunDebugItemModel() {
                    Latitude = s.Latitude,
                    Longitude = s.Longitude,
                    Accuracy = s.Accuracy,
                    TimeStamp = s.TimeStamp,
                    Speed = s.Speed
                }).ToList()
        });
    }

    private async Task GetLocation()
    {
        if (geo.RequestCounter > 3)
            return;
        Interlocked.Increment(ref geo.RequestCounter);
        await geo.semaphoreSlim.WaitAsync();
        geo.Request = DateTime.UtcNow;
        string getLoc = await _js.InvokeAsync<string>("GetLocationDebug");

    }

    private async void GeoData(double[] data)
    {
        geo.Duration = DateTime.UtcNow - geo.Request;
        Interlocked.Decrement(ref geo.RequestCounter);
        geo.semaphoreSlim.Release();
        RunItem item = new RunItem(data[0], data[1], data[2], data[3], data[4]);
        geo.Count++;
        geo.Error = "";
        geo.RunItem = item;
        Run.RunItems.Add(item);
        // await _js.InvokeVoidAsync("AddMarker", data[0], data[1], geo.Count);
        await InvokeAsync(() => StateHasChanged());
    }

    private void Error(string err)
    {
        geo.Error = err;
        geo.Duration = DateTime.UtcNow - geo.Request;
        geo.RunItem = null;
        Interlocked.Decrement(ref geo.RequestCounter);
        errors.Add(err);
        geo.semaphoreSlim.Release();
    }

    [JSInvokable]
    public static void UpdateRunCallerDebug(double[] pos)
    {
        action.Invoke(pos);
    }

    [JSInvokable]
    public static void ErrorCallerDebug(string err)
    {
        actionErr.Invoke(err);
    }

    class GetLocationModel
    {
        public DateTime Request { get; set; }
        public TimeSpan Duration { get; set; }
        public int Count { get; set; }
        public int RequestCounter;
        public SemaphoreSlim semaphoreSlim = new SemaphoreSlim(1, 1);
        public RunItem RunItem { get; set; }
        public string Error { get; set; }
    }


    public void Dispose() {
        Stop();
    }

    private double angleFromCoordinate(double lat1, double long1, double lat2,
            double long2) {

        double dLon = (long2 - long1);

        double y = Math.Sin(dLon) * Math.Cos(lat2);
        double x = Math.Cos(lat1) * Math.Sin(lat2) - Math.Sin(lat1)
                * Math.Cos(lat2) * Math.Cos(dLon);

        double brng = Math.Atan2(y, x);

        brng = (180 / Math.PI) * brng;
        brng = (brng + 360) % 360;
        // brng = 360 - brng; // count degrees counter-clockwise - remove to make clockwise

        return brng;
    }

    private double GetDistance(double lat1, double long1, double lat2, double long2)
    {
        var d1 = lat1 * (Math.PI / 180.0);
        var num1 = long1 * (Math.PI / 180.0);
        var d2 = lat2 * (Math.PI / 180.0);
        var num2 = long2 * (Math.PI / 180.0) - num1;
        var d3 = Math.Pow(Math.Sin((d2 - d1) / 2.0), 2.0) + Math.Cos(d1) * Math.Cos(d2) * Math.Pow(Math.Sin(num2 / 2.0), 2.0);
        return 6376500.0 * (2.0 * Math.Atan2(Math.Sqrt(d3), Math.Sqrt(1.0 - d3)));
        // return 2.0 * Math.Atan2(Math.Sqrt(d3), Math.Sqrt(1.0 - d3));
    }
}
